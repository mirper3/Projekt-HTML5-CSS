<!DOCTYPE html>
<html>
<head>

    <title>Peti Oblak - Website</title>
    <meta http-equiv="content-type" content="text/html; charset=utf-8">
    <meta name="description" content="Peti Oblak - Website">
    <meta name="keywords" content="cybersecurity, network, firewall, antivirus">
    <meta name="author" content="Miroslav Perić">
    <meta name="viewport" content="width=device-width; initial-scale=1.0; maximum-scale=1.0; user-scalable=0;">
    <link rel="icon" href="favicon.ico" type="image/x-icon" />
    <link rel="shortcut icon" href="favicon.ico" type="image/x-icon" />
    <link rel="stylesheet" href="style.css">
    <link href="https://fonts.googleapis.com/css?family=Oswald" rel="stylesheet">

</head>
<body>
    <header>
        <div class="homepage-image"></div>
        <nav>
            <ul>
                <li><a href="index.html">Home</a></li>
                <li><a href="news.html">News</a></li>
                <li><a href="contact.html">Contact</a></li>
                <li><a href="about-us.html">About</a></li>
                <li><a href="gallery.html">Gallery</a></li>
            </ul>
        </nav>
    </header>
    <main>
        <h1>NEWS</h1>
        <div id="news_gallery">
        <p class="description">Chrome, Firefox, Edge, and Yandex are all affected in widespread ad-injection campaign.</p>
        </div>
        <hr>
        <div class="news">
            <h2>Docker security:</h2>
            <p>
                There are four major areas to consider when reviewing Docker security:
            </p>
            <p>1. the intrinsic security of the kernel and its support for namespaces and cgroups;</p>
            <p>2. the attack surface of the Docker daemon itself;</p>
            <p>3. loopholes in the container configuration profile, either by default, or when customized by users.</p>
            <p>4. the “hardening” security features of the kernel and how they interact with containers.</p>
            </p>
            <p class="description">Kernel namespaces</p>
            <p>Docker containers are very similar to LXC containers, and they have similar security features. When you start a container with docker run, behind the scenes Docker creates a set of namespaces and control groups for the container.</p>
            <p>Namespaces provide the first and most straightforward form of isolation: processes running within a container cannot see, and even less affect, processes running in another container, or in the host system.</p>
            <p>
                Each container also gets its own network stack, meaning that a container doesn’t get privileged access to the sockets or interfaces of another container. Of course, if the host system is setup accordingly, containers can interact with each other through their respective network interfaces — just like they can interact with external hosts. When you specify public ports for your containers or use links then IP traffic is allowed between containers. They can ping each other, send/receive UDP packets, and establish TCP connections, but that can be restricted if necessary. From a network architecture point of view, all containers on a given Docker host are sitting on bridge interfaces. This means that they are just like physical machines connected through a common Ethernet switch; no more, no less.

                How mature is the code providing kernel namespaces and private networking? Kernel namespaces were introduced between kernel version 2.6.15 and 2.6.26. This means that since July 2008 (date of the 2.6.26 release ), namespace code has been exercised and scrutinized on a large number of production systems. And there is more: the design and inspiration for the namespaces code are even older. Namespaces are actually an effort to reimplement the features of OpenVZ in such a way that they could be merged within the mainstream kernel. And OpenVZ was initially released in 2005, so both the design and the implementation are pretty mature.
            </p>
            <p class="description">Control groups</p>
            <p>
                Control Groups are another key component of Linux Containers. They implement resource accounting and limiting. They provide many useful metrics, but they also help ensure that each container gets its fair share of memory, CPU, disk I/O; and, more importantly, that a single container cannot bring the system down by exhausting one of those resources.

                So while they do not play a role in preventing one container from accessing or affecting the data and processes of another container, they are essential to fend off some denial-of-service attacks. They are particularly important on multi-tenant platforms, like public and private PaaS, to guarantee a consistent uptime (and performance) even when some applications start to misbehave.

                Control Groups have been around for a while as well: the code was started in 2006, and initially merged in kernel 2.6.24.
            </p>
            <p class="description">Docker daemon attack surface</p>
            <p>
                Running containers (and applications) with Docker implies running the Docker daemon. This daemon requires root privileges unless you opt-in to Rootless mode (experimental), and you should therefore be aware of some important details.

                First of all, only trusted users should be allowed to control your Docker daemon. This is a direct consequence of some powerful Docker features. Specifically, Docker allows you to share a directory between the Docker host and a guest container; and it allows you to do so without limiting the access rights of the container. This means that you can start a container where the /host directory is the / directory on your host; and the container can alter your host filesystem without any restriction. This is similar to how virtualization systems allow filesystem resource sharing. Nothing prevents you from sharing your root filesystem (or even your root block device) with a virtual machine.

                This has a strong security implication: for example, if you instrument Docker from a web server to provision containers through an API, you should be even more careful than usual with parameter checking, to make sure that a malicious user cannot pass crafted parameters causing Docker to create arbitrary containers.

                For this reason, the REST API endpoint (used by the Docker CLI to communicate with the Docker daemon) changed in Docker 0.5.2, and now uses a UNIX socket instead of a TCP socket bound on 127.0.0.1 (the latter being prone to cross-site request forgery attacks if you happen to run Docker directly on your local machine, outside of a VM). You can then use traditional UNIX permission checks to limit access to the control socket.

                You can also expose the REST API over HTTP if you explicitly decide to do so. However, if you do that, be aware of the above mentioned security implications. Note that even if you have a firewall to limit accesses to the REST API endpoint from other hosts in the network, the endpoint can be still accessible from containers, and it can easily result in the privilege escalation. Therefore it is mandatory to secure API endpoints with HTTPS and certificates. It is also recommended to ensure that it is reachable only from a trusted network or VPN.

                You can also use DOCKER_HOST=ssh://USER@HOST or ssh -L /path/to/docker.sock:/var/run/docker.sock instead if you prefer SSH over TLS.

                The daemon is also potentially vulnerable to other inputs, such as image loading from either disk with docker load, or from the network with docker pull. As of Docker 1.3.2, images are now extracted in a chrooted subprocess on Linux/Unix platforms, being the first-step in a wider effort toward privilege separation. As of Docker 1.10.0, all images are stored and accessed by the cryptographic checksums of their contents, limiting the possibility of an attacker causing a collision with an existing image.

                Finally, if you run Docker on a server, it is recommended to run exclusively Docker on the server, and move all other services within containers controlled by Docker. Of course, it is fine to keep your favorite admin tools (probably at least an SSH server), as well as existing monitoring/supervision processes, such as NRPE and collectd.

            </p>
            <p class="description">Linux kernel capabilities</p>
            <p>By default, Docker starts containers with a restricted set of capabilities. What does that mean?</p>
            <p>
                Capabilities turn the binary “root/non-root” dichotomy into a fine-grained access control system. Processes (like web servers) that just need to bind on a port below 1024 do not need to run as root: they can just be granted the net_bind_service capability instead. And there are many other capabilities, for almost all the specific areas where root privileges are usually needed.

                This means a lot for container security; let’s see why!

                Typical servers run several processes as root, including the SSH daemon, cron daemon, logging daemons, kernel modules, network configuration tools, and more. A container is different, because almost all of those tasks are handled by the infrastructure around the container:
            </p>
            <p>1. SSH access are typically managed by a single server running on the Docker host;</p>
            <p>
                2. cron, when necessary, should run as a user process, dedicated and tailored for the app that needs its scheduling service, rather than as a platform-wide facility;
            </p>
            <p>3. log management is also typically handed to Docker, or to third-party services like Loggly or Splunk;</p>
            <p>4. hardware management is irrelevant, meaning that you never need to run udevd or equivalent daemons within containers;</p>
            <p>5. network management happens outside of the containers, enforcing separation of concerns as much as possible, meaning that a container should never need to perform ifconfig, route, or ip commands (except when a container is specifically engineered to behave like a router or firewall, of course).</p>
            <p>This means that in most cases, containers do not need “real” root privileges at all. And therefore, containers can run with a reduced capability set; meaning that “root” within a container has much less privileges than the real “root”. For instance, it is possible to:</p>
            <p>1. deny all “mount” operations;</p>
            <p>2. deny access to raw sockets (to prevent packet spoofing);</p>
            <p>3. deny access to some filesystem operations, like creating new device nodes, changing the owner of files, or altering attributes (including the immutable flag);</p>
            <p>4. deny module loading;</p>
            <p>5. and many others.</p>
            <p>
                This means that even if an intruder manages to escalate to root within a container, it is much harder to do serious damage, or to escalate to the host.

                This doesn’t affect regular web apps, but reduces the vectors of attack by malicious users considerably. By default Docker drops all capabilities except those needed, an allowlist instead of a denylist approach. You can see a full list of available capabilities in Linux manpages.

                One primary risk with running Docker containers is that the default set of capabilities and mounts given to a container may provide incomplete isolation, either independently, or when used in combination with kernel vulnerabilities.

                Docker supports the addition and removal of capabilities, allowing use of a non-default profile. This may make Docker more secure through capability removal, or less secure through the addition of capabilities. The best practice for users would be to remove all capabilities except those explicitly required for their processes.
            </p>
            <p>Source : <a href="https://docs.docker.com/engine/security/">https://docs.docker.com/engine/security/</a></p>
            <p><a href="news.html">Back to news</a></p>
        </div>
    </main>
    <footer>
        <p>Copyright &copy; 2020 Miroslav Perić</p>
    </footer>
</body>
</html>